enum MyEnum
{
    ENUM_VALUE_1,
    ENUM_VALUE_2,
    ENUM_VALUE_3
};

@bit_bound(8)
bitmask MyBitMask
{
	@position(0) flag0,
	@position(1) flag1,
	@position(4) flag4,
	@position(6) flag6
};

typedef long MyAlias;

struct MyStructure
{
    long field1;
    float field2;
};

union MyUnion switch (long)
{
    case 0: long longValue;
    case 1: float floatValue;
};

bitset MyBitset
{
	bitfield<3> a;
	bitfield<1> b;
	bitfield<4>;
	bitfield<10> c;
	bitfield<12, short> d;
};


typedef short alias_array[2];
typedef sequence<short> alias_sequence;
typedef map<long, long> alias_map;

struct Sequences
{
    sequence<short> var_sequence_short;
    sequence<unsigned short> var_sequence_ushort;
    sequence<long> var_sequence_long;
    sequence<unsigned long> var_sequence_ulong;
    sequence<long long> var_sequence_longlong;
    sequence<unsigned long long> var_sequence_ulonglong;
    sequence<float> var_sequence_float;
    sequence<double> var_sequence_double;
    sequence<long double> var_sequence_longdouble;
    sequence<boolean> var_sequence_boolean;
    sequence<octet> var_sequence_octet;
    sequence<char> var_sequence_char;
    sequence<wchar> var_sequence_wchar;
    sequence<string> var_sequence_string;
    sequence<wstring> var_sequence_wstring;

    sequence<MyEnum> var_sequence_enum;
    sequence<MyBitMask> var_sequence_bitmask;
    sequence<MyAlias> var_sequence_alias;

    sequence<alias_array> var_sequence_short_array;
    sequence<alias_sequence> var_sequence_sequence;
    sequence<alias_map> var_sequence_map;

    sequence<MyUnion> var_sequence_union;
    sequence<MyStructure> var_sequence_structure;
    sequence<MyBitset> var_sequence_bitset;
};

struct BoundedSmallSequences
{
    sequence<short, 1> var_sequence_small;
};

struct BoundedBigSequences
{
    sequence<short, 41925> var_sequence_big;
};